-- Create new tables for orders, send, and receive transactions
CREATE TABLE IF NOT EXISTS "public"."orders" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT timezone('utc'::text, now()),
    "user_id" uuid NOT NULL REFERENCES auth.users(id),
    "date" timestamp with time zone NOT NULL,
    "type" varchar(4) NOT NULL CHECK (type IN ('buy', 'sell')),
    "asset" varchar(10) NOT NULL,
    "price" numeric(20,8) NOT NULL,
    "exchange" varchar(50),
    
    -- Buy fields
    "buy_fiat_amount" numeric(20,8),
    "buy_currency" varchar(10),
    "buy_btc_amount" numeric(20,8),
    "received_btc_amount" numeric(20,8),
    "received_currency" varchar(10),
    
    -- Sell fields
    "sell_btc_amount" numeric(20,8),
    "sell_btc_currency" varchar(10),
    "received_fiat_amount" numeric(20,8),
    "received_fiat_currency" varchar(10),
    
    -- Fee information
    "service_fee" numeric(20,8),
    "service_fee_currency" varchar(10),

    -- Constraints
    CONSTRAINT check_amounts_positive CHECK (
        COALESCE(buy_fiat_amount, 0) >= 0 AND
        COALESCE(buy_btc_amount, 0) >= 0 AND
        COALESCE(received_btc_amount, 0) >= 0 AND
        COALESCE(sell_btc_amount, 0) >= 0 AND
        COALESCE(received_fiat_amount, 0) >= 0 AND
        COALESCE(service_fee, 0) >= 0
    ),
    CONSTRAINT check_buy_fields CHECK (
        (type = 'buy' AND buy_fiat_amount IS NOT NULL AND buy_currency IS NOT NULL AND received_btc_amount IS NOT NULL) OR
        type != 'buy'
    ),
    CONSTRAINT check_sell_fields CHECK (
        (type = 'sell' AND sell_btc_amount IS NOT NULL AND received_fiat_amount IS NOT NULL AND received_fiat_currency IS NOT NULL) OR
        type != 'sell'
    )
);

CREATE TABLE IF NOT EXISTS "public"."send" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT timezone('utc'::text, now()),
    "user_id" uuid NOT NULL REFERENCES auth.users(id),
    "date" timestamp with time zone NOT NULL,
    "asset" varchar(10) NOT NULL,
    "type" varchar(4) NOT NULL DEFAULT 'send' CHECK (type = 'send'),
    
    -- Send fields
    "sent_amount" numeric(20,8) NOT NULL,
    "sent_currency" varchar(10) NOT NULL DEFAULT 'BTC' CHECK (sent_currency = 'BTC'),
    
    -- Fee information
    "network_fee" numeric(20,8),
    "network_fee_currency" varchar(10) DEFAULT 'BTC' CHECK (network_fee_currency = 'BTC'),

    -- Constraints
    CONSTRAINT check_amounts_positive CHECK (
        sent_amount >= 0 AND
        COALESCE(network_fee, 0) >= 0
    )
);

CREATE TABLE IF NOT EXISTS "public"."receive" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT timezone('utc'::text, now()),
    "user_id" uuid NOT NULL REFERENCES auth.users(id),
    "date" timestamp with time zone NOT NULL,
    "asset" varchar(10) NOT NULL,
    "type" varchar(7) NOT NULL DEFAULT 'receive' CHECK (type = 'receive'),
    "price" numeric(20,8) NOT NULL,
    "exchange" varchar(50),
    
    -- Receive fields
    "received_transfer_amount" numeric(20,8) NOT NULL,
    "received_currency" varchar(10) NOT NULL DEFAULT 'BTC' CHECK (received_currency = 'BTC'),

    -- Constraints
    CONSTRAINT check_amounts_positive CHECK (
        received_transfer_amount >= 0
    )
);

-- Create indexes if they don't exist
DO $$ 
BEGIN
    -- Orders indexes
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_user_id') THEN
        CREATE INDEX idx_orders_user_id ON public.orders(user_id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_date') THEN
        CREATE INDEX idx_orders_date ON public.orders(date);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_type') THEN
        CREATE INDEX idx_orders_type ON public.orders(type);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_asset') THEN
        CREATE INDEX idx_orders_asset ON public.orders(asset);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_exchange') THEN
        CREATE INDEX idx_orders_exchange ON public.orders(exchange);
    END IF;

    -- Send indexes
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_send_user_id') THEN
        CREATE INDEX idx_send_user_id ON public.send(user_id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_send_date') THEN
        CREATE INDEX idx_send_date ON public.send(date);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_send_asset') THEN
        CREATE INDEX idx_send_asset ON public.send(asset);
    END IF;

    -- Receive indexes
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_receive_user_id') THEN
        CREATE INDEX idx_receive_user_id ON public.receive(user_id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_receive_date') THEN
        CREATE INDEX idx_receive_date ON public.receive(date);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_receive_asset') THEN
        CREATE INDEX idx_receive_asset ON public.receive(asset);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_receive_exchange') THEN
        CREATE INDEX idx_receive_exchange ON public.receive(exchange);
    END IF;
END $$;

-- Add triggers for updated_at
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_updated_at_orders') THEN
        CREATE TRIGGER set_updated_at_orders
            BEFORE UPDATE ON public.orders
            FOR EACH ROW
            EXECUTE FUNCTION public.update_updated_at_column();
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_updated_at_send') THEN
        CREATE TRIGGER set_updated_at_send
            BEFORE UPDATE ON public.send
            FOR EACH ROW
            EXECUTE FUNCTION public.update_updated_at_column();
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_updated_at_receive') THEN
        CREATE TRIGGER set_updated_at_receive
            BEFORE UPDATE ON public.receive
            FOR EACH ROW
            EXECUTE FUNCTION public.update_updated_at_column();
    END IF;
END $$;

-- Add user_id validation triggers
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'ensure_user_id_matches_auth_orders') THEN
        CREATE TRIGGER ensure_user_id_matches_auth_orders
            BEFORE INSERT OR UPDATE ON public.orders
            FOR EACH ROW
            EXECUTE FUNCTION public.ensure_user_id_matches_auth();
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'ensure_user_id_matches_auth_send') THEN
        CREATE TRIGGER ensure_user_id_matches_auth_send
            BEFORE INSERT OR UPDATE ON public.send
            FOR EACH ROW
            EXECUTE FUNCTION public.ensure_user_id_matches_auth();
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'ensure_user_id_matches_auth_receive') THEN
        CREATE TRIGGER ensure_user_id_matches_auth_receive
            BEFORE INSERT OR UPDATE ON public.receive
            FOR EACH ROW
            EXECUTE FUNCTION public.ensure_user_id_matches_auth();
    END IF;
END $$;

-- Add RLS policies
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.send ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.receive ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies 
        WHERE schemaname = 'public' 
        AND tablename = 'orders' 
        AND policyname = 'Users can only see their own orders'
    ) THEN
        CREATE POLICY "Users can only see their own orders"
            ON public.orders FOR ALL
            USING (auth.uid() = user_id)
            WITH CHECK (auth.uid() = user_id);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies 
        WHERE schemaname = 'public' 
        AND tablename = 'send' 
        AND policyname = 'Users can only see their own send transactions'
    ) THEN
        CREATE POLICY "Users can only see their own send transactions"
            ON public.send FOR ALL
            USING (auth.uid() = user_id)
            WITH CHECK (auth.uid() = user_id);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies 
        WHERE schemaname = 'public' 
        AND tablename = 'receive' 
        AND policyname = 'Users can only see their own receive transactions'
    ) THEN
        CREATE POLICY "Users can only see their own receive transactions"
            ON public.receive FOR ALL
            USING (auth.uid() = user_id)
            WITH CHECK (auth.uid() = user_id);
    END IF;
END $$; 