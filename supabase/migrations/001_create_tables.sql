-- Create the transactions table with the new schema
CREATE TABLE transactions (
    -- Primary key and metadata
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id UUID REFERENCES auth.users NOT NULL,

    -- Core transaction details
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    type VARCHAR(10) NOT NULL,
    asset VARCHAR(10) NOT NULL,
    
    -- Amount fields with explicit nullability
    sent_amount DECIMAL(20, 8),
    sent_currency VARCHAR(10),
    buy_amount DECIMAL(20, 8),
    buy_currency VARCHAR(10),
    sell_amount DECIMAL(20, 8),
    sell_currency VARCHAR(10),
    price DECIMAL(20, 8) NOT NULL,
    received_amount DECIMAL(20, 8),
    received_currency VARCHAR(10),
    
    -- Additional details
    exchange VARCHAR(50),
    
    -- Fee information
    network_fee DECIMAL(20, 8),
    network_currency VARCHAR(10),
    service_fee DECIMAL(20, 8),
    service_fee_currency VARCHAR(10),

    -- Constraints
    CONSTRAINT check_transaction_type 
        CHECK (type IN ('Buy', 'Sell', 'Send', 'Receive')),
    CONSTRAINT check_amounts_positive
        CHECK (
            COALESCE(sent_amount, 0) >= 0 AND
            COALESCE(buy_amount, 0) >= 0 AND
            COALESCE(sell_amount, 0) >= 0 AND
            COALESCE(received_amount, 0) >= 0 AND
            COALESCE(network_fee, 0) >= 0 AND
            COALESCE(service_fee, 0) >= 0
        ),
    -- Ensure at least one amount is present based on transaction type
    CONSTRAINT check_required_amounts
        CHECK (
            (type IN ('Buy', 'Receive') AND received_amount IS NOT NULL) OR
            (type IN ('Sell', 'Send') AND sent_amount IS NOT NULL)
        ),
    -- Ensure currency is present if amount is present
    CONSTRAINT check_currency_presence
        CHECK (
            (sent_amount IS NULL OR sent_currency IS NOT NULL) AND
            (buy_amount IS NULL OR buy_currency IS NOT NULL) AND
            (sell_amount IS NULL OR sell_currency IS NOT NULL) AND
            (received_amount IS NULL OR received_currency IS NOT NULL) AND
            (network_fee IS NULL OR network_currency IS NOT NULL) AND
            (service_fee IS NULL OR service_fee_currency IS NOT NULL)
        )
);

-- Create indexes for performance
CREATE INDEX idx_transactions_user_id ON transactions(user_id);
CREATE INDEX idx_transactions_date ON transactions(date);
CREATE INDEX idx_transactions_type ON transactions(type);
CREATE INDEX idx_transactions_asset ON transactions(asset);
CREATE INDEX idx_transactions_exchange ON transactions(exchange);
CREATE INDEX idx_transactions_created_at ON transactions(created_at);

-- Add updated_at trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for updated_at
CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own transactions" ON transactions
    FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own transactions" ON transactions
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own transactions" ON transactions
    FOR UPDATE
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own transactions" ON transactions
    FOR DELETE
    USING (auth.uid() = user_id);

-- Create a function to ensure user_id matches the authenticated user
CREATE OR REPLACE FUNCTION ensure_user_id_matches_auth()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.user_id != auth.uid() THEN
        RAISE EXCEPTION 'user_id must match the authenticated user';
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to enforce user_id matching
CREATE TRIGGER ensure_user_id_matches_auth_trigger
    BEFORE INSERT OR UPDATE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION ensure_user_id_matches_auth(); 