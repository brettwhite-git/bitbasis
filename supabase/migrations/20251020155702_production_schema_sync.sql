create extension if not exists "pg_net" with schema "public" version '0.14.0';

create type "public"."subscription_status" as enum ('trialing', 'active', 'canceled', 'incomplete', 'incomplete_expired', 'past_due', 'unpaid');

create sequence "public"."btc_monthly_close_id_seq";

create table "public"."ath" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "price_usd" numeric(20,2) not null,
    "ath_date" timestamp with time zone not null,
    "source" character varying(50) default 'coinpaprika'::character varying
);


alter table "public"."ath" enable row level security;

create table "public"."btc_monthly_close" (
    "id" bigint not null default nextval('btc_monthly_close_id_seq'::regclass),
    "date" date not null,
    "close" numeric(15,4) not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."btc_monthly_close" enable row level security;

create table "public"."csv_uploads" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "filename" text not null,
    "status" text not null default 'pending'::text,
    "row_count" integer,
    "imported_row_count" integer,
    "error_message" text,
    "original_filename" text not null,
    "file_size" bigint not null
);


alter table "public"."csv_uploads" enable row level security;

create table "public"."customers" (
    "id" uuid not null,
    "stripe_customer_id" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now())
);


alter table "public"."customers" enable row level security;

create table "public"."fear_greed_index" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "value" integer not null,
    "classification" text not null,
    "last_updated" timestamp with time zone not null,
    "date" date
);


alter table "public"."fear_greed_index" enable row level security;

create table "public"."spot_price" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "price_usd" numeric(20,2) not null,
    "source" character varying(50) default 'coinpaprika'::character varying
);


alter table "public"."spot_price" enable row level security;

create table "public"."subscriptions" (
    "id" text not null,
    "user_id" uuid not null,
    "status" subscription_status,
    "metadata" jsonb,
    "price_id" text,
    "quantity" integer,
    "cancel_at_period_end" boolean default false,
    "created" text not null,
    "current_period_start" text not null,
    "current_period_end" text not null,
    "ended_at" text,
    "cancel_at" text,
    "canceled_at" text,
    "trial_start" text,
    "trial_end" text
);


alter table "public"."subscriptions" enable row level security;

create table "public"."terms_acceptance" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "accepted_at" timestamp with time zone not null default now(),
    "terms_version" character varying(50) not null,
    "privacy_version" character varying(50) not null,
    "acceptance_type" character varying(20) not null default 'signup'::character varying,
    "acceptance_method" character varying(20) not null,
    "ip_address" character varying(50),
    "user_agent" text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."terms_acceptance" enable row level security;

create table "public"."transactions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now()),
    "user_id" uuid not null,
    "date" timestamp with time zone not null,
    "type" character varying(10) not null,
    "asset" character varying(10) not null default 'BTC'::character varying,
    "sent_amount" numeric(20,8),
    "sent_currency" character varying(10),
    "sent_cost_basis" numeric(20,8),
    "from_address" character varying(100),
    "from_address_name" character varying(100),
    "to_address" character varying(100),
    "to_address_name" character varying(100),
    "received_amount" numeric(20,8),
    "received_currency" character varying(10),
    "received_cost_basis" numeric(20,8),
    "fee_amount" numeric(20,8),
    "fee_currency" character varying(10),
    "fee_cost_basis" numeric(20,8),
    "realized_return" numeric(20,8),
    "fee_realized_return" numeric(20,8),
    "transaction_hash" character varying(70),
    "comment" text,
    "price" numeric(20,8),
    "csv_upload_id" uuid
);


alter table "public"."transactions" enable row level security;

alter sequence "public"."btc_monthly_close_id_seq" owned by "public"."btc_monthly_close"."id";

CREATE UNIQUE INDEX ath_pkey ON public.ath USING btree (id);

CREATE UNIQUE INDEX btc_monthly_close_date_key ON public.btc_monthly_close USING btree (date);

CREATE UNIQUE INDEX btc_monthly_close_pkey ON public.btc_monthly_close USING btree (id);

CREATE UNIQUE INDEX csv_uploads_pkey ON public.csv_uploads USING btree (id);

CREATE UNIQUE INDEX customers_pkey ON public.customers USING btree (id);

CREATE UNIQUE INDEX customers_stripe_customer_id_key ON public.customers USING btree (stripe_customer_id);

CREATE UNIQUE INDEX fear_greed_index_date_key ON public.fear_greed_index USING btree (date);

CREATE UNIQUE INDEX fear_greed_index_pkey ON public.fear_greed_index USING btree (id);

CREATE INDEX idx_btc_monthly_close_created_at ON public.btc_monthly_close USING btree (created_at);

CREATE INDEX idx_btc_monthly_close_date ON public.btc_monthly_close USING btree (date DESC);

CREATE INDEX idx_csv_uploads_status ON public.csv_uploads USING btree (status);

CREATE INDEX idx_csv_uploads_user_id ON public.csv_uploads USING btree (user_id);

CREATE INDEX idx_customers_stripe_id ON public.customers USING btree (stripe_customer_id);

CREATE INDEX idx_spot_price_updated_at ON public.spot_price USING btree (updated_at);

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions USING btree (user_id);

CREATE INDEX idx_terms_acceptance_user_id ON public.terms_acceptance USING btree (user_id);

CREATE INDEX idx_transactions_date ON public.transactions USING btree (date);

CREATE INDEX idx_transactions_type ON public.transactions USING btree (type);

CREATE INDEX idx_transactions_user_date ON public.transactions USING btree (user_id, date);

CREATE INDEX idx_transactions_user_id ON public.transactions USING btree (user_id);

CREATE UNIQUE INDEX spot_price_pkey ON public.spot_price USING btree (id);

CREATE UNIQUE INDEX subscriptions_pkey ON public.subscriptions USING btree (id);

CREATE UNIQUE INDEX terms_acceptance_pkey ON public.terms_acceptance USING btree (id);

CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id);

alter table "public"."ath" add constraint "ath_pkey" PRIMARY KEY using index "ath_pkey";

alter table "public"."btc_monthly_close" add constraint "btc_monthly_close_pkey" PRIMARY KEY using index "btc_monthly_close_pkey";

alter table "public"."csv_uploads" add constraint "csv_uploads_pkey" PRIMARY KEY using index "csv_uploads_pkey";

alter table "public"."customers" add constraint "customers_pkey" PRIMARY KEY using index "customers_pkey";

alter table "public"."fear_greed_index" add constraint "fear_greed_index_pkey" PRIMARY KEY using index "fear_greed_index_pkey";

alter table "public"."spot_price" add constraint "spot_price_pkey" PRIMARY KEY using index "spot_price_pkey";

alter table "public"."subscriptions" add constraint "subscriptions_pkey" PRIMARY KEY using index "subscriptions_pkey";

alter table "public"."terms_acceptance" add constraint "terms_acceptance_pkey" PRIMARY KEY using index "terms_acceptance_pkey";

alter table "public"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "public"."btc_monthly_close" add constraint "btc_monthly_close_date_key" UNIQUE using index "btc_monthly_close_date_key";

alter table "public"."btc_monthly_close" add constraint "btc_monthly_close_price_positive" CHECK ((close > (0)::numeric)) not valid;

alter table "public"."btc_monthly_close" validate constraint "btc_monthly_close_price_positive";

alter table "public"."btc_monthly_close" add constraint "btc_monthly_close_price_reasonable" CHECK ((close < (10000000)::numeric)) not valid;

alter table "public"."btc_monthly_close" validate constraint "btc_monthly_close_price_reasonable";

alter table "public"."csv_uploads" add constraint "check_status" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'error'::text]))) not valid;

alter table "public"."csv_uploads" validate constraint "check_status";

alter table "public"."csv_uploads" add constraint "csv_uploads_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."csv_uploads" validate constraint "csv_uploads_user_id_fkey";

alter table "public"."customers" add constraint "customers_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."customers" validate constraint "customers_id_fkey";

alter table "public"."customers" add constraint "customers_stripe_customer_id_key" UNIQUE using index "customers_stripe_customer_id_key";

alter table "public"."fear_greed_index" add constraint "fear_greed_index_date_key" UNIQUE using index "fear_greed_index_date_key";

alter table "public"."subscriptions" add constraint "subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_user_id_fkey";

alter table "public"."terms_acceptance" add constraint "terms_acceptance_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."terms_acceptance" validate constraint "terms_acceptance_user_id_fkey";

alter table "public"."transactions" add constraint "check_amounts_positive" CHECK (((COALESCE(sent_amount, (0)::numeric) >= (0)::numeric) AND (COALESCE(received_amount, (0)::numeric) >= (0)::numeric) AND (COALESCE(fee_amount, (0)::numeric) >= (0)::numeric))) not valid;

alter table "public"."transactions" validate constraint "check_amounts_positive";

alter table "public"."transactions" add constraint "check_buy_fields" CHECK (((((type)::text = 'buy'::text) AND (received_amount IS NOT NULL) AND (received_currency IS NOT NULL)) OR ((type)::text <> 'buy'::text))) not valid;

alter table "public"."transactions" validate constraint "check_buy_fields";

alter table "public"."transactions" add constraint "check_interest_fields" CHECK (((((type)::text = 'interest'::text) AND (received_amount IS NOT NULL) AND (received_currency IS NOT NULL)) OR ((type)::text <> 'interest'::text))) not valid;

alter table "public"."transactions" validate constraint "check_interest_fields";

alter table "public"."transactions" add constraint "check_sell_fields" CHECK (((((type)::text = 'sell'::text) AND (sent_amount IS NOT NULL) AND (sent_currency IS NOT NULL) AND (received_amount IS NOT NULL) AND (received_currency IS NOT NULL)) OR ((type)::text <> 'sell'::text))) not valid;

alter table "public"."transactions" validate constraint "check_sell_fields";

alter table "public"."transactions" add constraint "check_transfer_fields" CHECK ((((((type)::text = 'deposit'::text) OR ((type)::text = 'withdrawal'::text)) AND (((sent_amount IS NOT NULL) AND (sent_currency IS NOT NULL)) OR ((received_amount IS NOT NULL) AND (received_currency IS NOT NULL)))) OR (((type)::text <> 'deposit'::text) AND ((type)::text <> 'withdrawal'::text)))) not valid;

alter table "public"."transactions" validate constraint "check_transfer_fields";

alter table "public"."transactions" add constraint "transactions_csv_upload_id_fkey" FOREIGN KEY (csv_upload_id) REFERENCES csv_uploads(id) ON DELETE CASCADE not valid;

alter table "public"."transactions" validate constraint "transactions_csv_upload_id_fkey";

alter table "public"."transactions" add constraint "transactions_type_check" CHECK (((type)::text = ANY ((ARRAY['buy'::character varying, 'sell'::character varying, 'deposit'::character varying, 'withdrawal'::character varying, 'interest'::character varying])::text[]))) not valid;

alter table "public"."transactions" validate constraint "transactions_type_check";

alter table "public"."transactions" add constraint "transactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."transactions" validate constraint "transactions_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.call_update_price()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    response http_response;
    status_code INT;
BEGIN
    -- Make the HTTP request using the correct http function format
    SELECT * INTO response FROM http((
        'POST',
        'https://npcvbxrshuflujcnikon.supabase.co/functions/v1/update-price',
        ARRAY[http_header('Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5wY3ZieHJzaHVmbHVqY25pa29uIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE5OTgxNTQsImV4cCI6MjA1NzU3NDE1NH0.Hya3qaRopTxcWIhLV_tEgWZonGWay2xgltJE7h4SVmA')],
        '{"source":"cron"}',
        ''
    )::http_request);
    
EXCEPTION WHEN OTHERS THEN
    -- Silently ignore errors to prevent cron job failures
    NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_user_add_transactions(user_uuid uuid, transaction_count integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  current_count INTEGER;
  sub_record RECORD;
  has_active_subscription BOOLEAN := FALSE;
BEGIN
  -- Get current transaction count
  current_count := get_user_transaction_count(user_uuid);
  
  -- Check if user has active subscription
  SELECT * INTO sub_record
  FROM subscriptions s
  WHERE s.user_id = user_uuid
  AND s.status IN ('active', 'trialing')
  ORDER BY s.created DESC
  LIMIT 1;
  
  IF sub_record.id IS NOT NULL THEN
    has_active_subscription := TRUE;
  END IF;
  
  -- If user has active subscription, they can add unlimited transactions
  IF has_active_subscription THEN
    RETURN TRUE;
  END IF;
  
  -- For free users, check if they would exceed the 50 transaction limit
  RETURN (current_count + transaction_count) <= 50;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_and_update_btc_ath()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  api_response JSONB;
  current_price NUMERIC(20, 2);
  ath_date TIMESTAMP WITH TIME ZONE;
  current_ath NUMERIC(20, 2);
  api_url TEXT := 'https://api.coinpaprika.com/v1/tickers/btc-bitcoin';
BEGIN
  -- Direct API call to Coinpaprika for BTC data using the tickers endpoint
  -- Use pg_net to make real HTTP requests
  
  -- Make API call to Coinpaprika
  SELECT
    content::jsonb INTO api_response
  FROM
    http((
      'GET',
      api_url,
      NULL,
      NULL,
      NULL
    ));
    
  -- Parse the response to get ATH data
  -- The API returns data like {"id":"btc-bitcoin",...,"quotes":{"USD":{"ath_price":69000,"ath_date":"2021-11-10T00:00:00Z",...}}}
  
  -- Extract ATH price and date from response (using quotes.USD structure)
  current_price := (api_response->'quotes'->'USD'->>'ath_price')::NUMERIC(20, 2);
  ath_date := (api_response->'quotes'->'USD'->>'ath_date')::TIMESTAMP WITH TIME ZONE;
  
  -- Add error handling for missing data
  IF current_price IS NULL OR ath_date IS NULL THEN
    RAISE EXCEPTION 'Missing ATH data in API response: price=%, date=%', current_price, ath_date;
  END IF;
  
  -- Get the current ATH if it exists
  SELECT price_usd INTO current_ath FROM public.ath
  ORDER BY price_usd DESC LIMIT 1;
  
  -- If no ATH exists or the new price is higher, update
  IF current_ath IS NULL OR current_price > current_ath THEN
    INSERT INTO public.ath (price_usd, ath_date, source, updated_at)
    VALUES (current_price, ath_date, 'coinpaprika', timezone('utc'::text, now()));
    
    -- Log to standard output for Supabase logs
    RAISE NOTICE 'New BTC ATH recorded: % USD on %', current_price, ath_date;
  ELSE
    -- Log that no update was needed
    RAISE NOTICE 'No new ATH. Current ATH remains: %', current_ath;
  END IF;
  
EXCEPTION WHEN OTHERS THEN
  -- Log error to standard output for Supabase logs
  RAISE WARNING 'Error checking BTC ATH: %', SQLERRM;
  
  -- Also log the API response for debugging
  RAISE WARNING 'API response: %', api_response;
  
  -- Re-raise the exception
  RAISE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.ensure_user_id_matches_auth()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.user_id != auth.uid() THEN
        RAISE EXCEPTION 'user_id must match the authenticated user';
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_and_store_btc_price_http()
 RETURNS text
 LANGUAGE plpgsql
AS $function$ 
DECLARE
    response http_response;
    response_content JSON;
    price_usd_text TEXT;
    price_usd_numeric NUMERIC;
    epoch_val DOUBLE PRECISION;
    current_timestamp BIGINT;
    current_date DATE;
    log_id BIGINT;
    result_message TEXT;
BEGIN
    -- Create initial log entry
    INSERT INTO public.price_update_logs(message, success)
    VALUES('Starting price update job', NULL)
    RETURNING id INTO log_id;
    
    -- Make the HTTP GET request 
    BEGIN
        SELECT * INTO response
        FROM http_get('https://mempool.space/api/v1/prices', null, null);
        
        -- Log the raw response
        UPDATE public.price_update_logs 
        SET details = jsonb_build_object('status', response.status, 'content', response.content)
        WHERE id = log_id;
    EXCEPTION WHEN OTHERS THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'HTTP request failed: ' || SQLERRM,
            details = jsonb_build_object('error', SQLERRM)
        WHERE id = log_id;
        RETURN 'Error: HTTP request failed: ' || SQLERRM;
    END;

    -- Check response status code
    IF response.status != 200 THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'API request failed with status ' || response.status::TEXT
        WHERE id = log_id;
        RETURN 'Error: API request failed with status ' || response.status::TEXT || '. Content: ' || response.content;
    END IF;

    -- Log successful API request
    UPDATE public.price_update_logs
    SET message = 'API request successful with status ' || response.status::TEXT
    WHERE id = log_id;

    -- Attempt to parse the response content as JSON
    BEGIN
        response_content := response.content::JSON;
    EXCEPTION WHEN others THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'Failed to parse API response as JSON',
            details = jsonb_build_object('content', response.content, 'error', SQLERRM)
        WHERE id = log_id;
        RETURN 'Error: Failed to parse API response as JSON. Content: ' || response.content || '. Error: ' || SQLERRM;
    END;

    -- Extract USD price as text first for safer conversion
    price_usd_text := response_content->>'USD';

    -- Check if USD key exists
    IF price_usd_text IS NULL THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'USD price not found in API response',
            details = jsonb_build_object('response', response_content)
        WHERE id = log_id;
        RETURN 'Error: USD price not found in API response. Response: ' || response.content;
    END IF;

    -- Attempt to convert price to numeric
    BEGIN
        price_usd_numeric := price_usd_text::NUMERIC;
    EXCEPTION WHEN others THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'Failed to convert USD price to numeric: ' || price_usd_text,
            details = jsonb_build_object('price_text', price_usd_text, 'error', SQLERRM)
        WHERE id = log_id;
        RETURN 'Error: Failed to convert USD price to numeric. Value: ' || price_usd_text || '. Error: ' || SQLERRM;
    END;

    -- Get current time info
    BEGIN
        epoch_val := extract(epoch from now());
    END;
    SELECT epoch_val::BIGINT INTO current_timestamp;
    SELECT epoch_val::TIMESTAMP WITH TIME ZONE::DATE INTO current_date;

    -- Log before insertion attempt
    UPDATE public.price_update_logs
    SET message = 'Attempting to insert price data',
        details = jsonb_build_object(
            'timestamp', current_timestamp,
            'price_usd', price_usd_numeric,
            'date', current_date
        )
    WHERE id = log_id;

    -- Insert into the historical price table
    BEGIN
        INSERT INTO public.historical_prices (timestamp, price_usd, date)
        VALUES (current_timestamp, price_usd_numeric, current_date)
        ON CONFLICT (timestamp) DO NOTHING;
        
        -- Check if a row was actually inserted
        IF FOUND THEN
            result_message := 'Successfully inserted new price data';
        ELSE
            result_message := 'No new data inserted (possible duplicate timestamp)';
        END IF;
        
    EXCEPTION WHEN OTHERS THEN
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'Database insertion failed: ' || SQLERRM,
            details = jsonb_build_object(
                'error', SQLERRM,
                'timestamp', current_timestamp,
                'price_usd', price_usd_numeric,
                'date', current_date
            )
        WHERE id = log_id;
        RETURN 'Error: Database insertion failed: ' || SQLERRM;
    END;

    -- Log success
    UPDATE public.price_update_logs
    SET success = TRUE,
        message = result_message
    WHERE id = log_id;

    RETURN 'Success (http): ' || result_message || ' - BTC price ' || price_usd_numeric::TEXT || ' USD at timestamp ' || current_timestamp::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        -- Log any other unexpected errors
        UPDATE public.price_update_logs
        SET success = FALSE,
            message = 'Unexpected error: ' || SQLERRM
        WHERE id = log_id;
        RETURN 'Error executing fetch_and_store_btc_price_http: ' || SQLERRM;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_and_update_btc_spot_price()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  api_response JSONB;
  current_price NUMERIC(20, 2);
BEGIN
  -- Log the start of the function using Postgres's RAISE NOTICE
  RAISE NOTICE 'Starting Bitcoin price update from Coinpaprika API';

  -- Fetch from Coinpaprika API using pg_net
  SELECT content::jsonb INTO api_response 
  FROM http((
    'GET',
    'https://api.coinpaprika.com/v1/tickers/btc-bitcoin',
    NULL,
    NULL,
    NULL
  )::http_request);
  
  -- Extract the price from the API response
  current_price = (api_response->'quotes'->'USD'->>'price')::NUMERIC(20, 2);
  
  -- Validate the price
  IF current_price IS NULL OR current_price <= 0 THEN
    RAISE EXCEPTION 'Invalid price received from API: %', current_price;
  END IF;
  
  -- Log success using RAISE NOTICE
  RAISE NOTICE 'Successfully fetched BTC price: % USD', current_price;
  
  -- Update the spot price using our function
  PERFORM public.update_spot_price(current_price, 'coinpaprika');
  
  -- Log completion
  RAISE NOTICE 'Completed Bitcoin price update to % USD', current_price;
  
EXCEPTION WHEN OTHERS THEN
  -- Log errors using RAISE WARNING
  RAISE WARNING 'Error updating BTC spot price: %', SQLERRM;
  
  -- Re-raise the exception
  RAISE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_last_day_of_month(input_date date)
 RETURNS date
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (DATE_TRUNC('month', input_date) + INTERVAL '1 month - 1 day')::DATE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_latest_terms_acceptance(p_user_id uuid)
 RETURNS TABLE(terms_version character varying, privacy_version character varying, accepted_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT ta.terms_version, ta.privacy_version, ta.accepted_at
  FROM public.terms_acceptance ta
  WHERE ta.user_id = p_user_id
  ORDER BY ta.accepted_at DESC
  LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_monthly_close_data(start_date date DEFAULT NULL::date, end_date date DEFAULT NULL::date)
 RETURNS TABLE(date date, close numeric, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    btc_monthly_close.date,
    btc_monthly_close.close,
    btc_monthly_close.created_at
  FROM public.btc_monthly_close
  WHERE 
    (start_date IS NULL OR btc_monthly_close.date >= start_date) AND
    (end_date IS NULL OR btc_monthly_close.date <= end_date)
  ORDER BY btc_monthly_close.date DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_subscription_info(user_uuid uuid)
 RETURNS TABLE(subscription_status text, transaction_count integer, can_add_transaction boolean, should_show_warning boolean, subscription_data jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  sub_record RECORD;
  tx_count INTEGER;
BEGIN
  -- Get transaction count
  tx_count := get_user_transaction_count(user_uuid);
  
  -- Get the most recent subscription for this user, prioritizing active ones
  SELECT * INTO sub_record
  FROM subscriptions s
  WHERE s.user_id = user_uuid
  ORDER BY 
    CASE WHEN s.status IN ('active', 'trialing') THEN 0 ELSE 1 END,  -- Active subscriptions first
    s.created DESC  -- Then by most recent
  LIMIT 1;
  
  -- Rest of the function logic remains the same...
  IF sub_record.id IS NULL THEN
    -- No subscription = free user
    RETURN QUERY SELECT 
      'free'::TEXT as subscription_status,
      tx_count as transaction_count,
      CASE WHEN tx_count < 50 THEN TRUE ELSE FALSE END as can_add_transaction,
      CASE WHEN tx_count >= 45 THEN TRUE ELSE FALSE END as should_show_warning,
      NULL::JSONB as subscription_data;
  ELSE
    -- Has subscription - check status and period end
    DECLARE
      effective_status TEXT;
      has_access BOOLEAN := FALSE;
      period_end_date TIMESTAMP;
    BEGIN
      period_end_date := sub_record.current_period_end::TIMESTAMP;
      
      -- Determine if user currently has access
      IF sub_record.status IN ('active', 'trialing') THEN
        has_access := TRUE;
        effective_status := sub_record.status::TEXT;
      ELSIF sub_record.status = 'past_due' THEN
        -- Past due users get a grace period until period end
        IF period_end_date > NOW() THEN
          has_access := TRUE;
          effective_status := 'past_due';
        ELSE
          has_access := FALSE;
          effective_status := 'expired';
        END IF;
      ELSIF sub_record.cancel_at_period_end = TRUE AND sub_record.status != 'canceled' THEN
        -- Cancelled but still in period
        IF period_end_date > NOW() THEN
          has_access := TRUE;
          effective_status := 'canceling';
        ELSE
          has_access := FALSE;
          effective_status := 'free';
        END IF;
      ELSE
        -- Canceled, incomplete, etc.
        has_access := FALSE;
        effective_status := CASE 
          WHEN sub_record.status = 'canceled' THEN 'free'
          ELSE sub_record.status::TEXT
        END;
      END IF;
      
      RETURN QUERY SELECT 
        effective_status as subscription_status,
        tx_count as transaction_count,
        CASE 
          WHEN has_access THEN TRUE
          WHEN tx_count < 50 THEN TRUE
          ELSE FALSE
        END as can_add_transaction,
        CASE 
          WHEN has_access THEN FALSE
          WHEN tx_count >= 45 THEN TRUE
          ELSE FALSE
        END as should_show_warning,
        CASE 
          WHEN sub_record.id IS NOT NULL THEN
            json_build_object(
              'id', sub_record.id,
              'price_id', sub_record.price_id,
              'metadata', sub_record.metadata,
              'status', sub_record.status,
              'current_period_end', sub_record.current_period_end,
              'cancel_at_period_end', sub_record.cancel_at_period_end,
              'past_due', sub_record.status = 'past_due',
              'has_access', has_access,
              'period_end_date', period_end_date
            )::JSONB
          ELSE NULL
        END as subscription_data;
    END;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_transaction_count(user_uuid uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM transactions 
    WHERE user_id = user_uuid
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_transaction_count_v2(user_uuid uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN get_user_transaction_count(user_uuid);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_last_day_of_month()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN CURRENT_DATE = public.get_last_day_of_month(CURRENT_DATE);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_historical_price_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.date := to_timestamp(NEW.timestamp)::date;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_ath(new_price_usd numeric, new_ath_date timestamp with time zone, source_name character varying DEFAULT 'coinpaprika'::character varying)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  current_ath NUMERIC(20, 2);
BEGIN
  -- Get the current ATH if it exists
  SELECT price_usd INTO current_ath FROM public.ath
  ORDER BY price_usd DESC LIMIT 1;
  
  -- Log what we're checking
  INSERT INTO public.price_update_logs (service, status, message)
  VALUES ('ath_update', 'info', 'Checking if ' || new_price_usd || ' > ' || COALESCE(current_ath::text, 'NULL'));

  -- If no ATH exists or the new price is higher, update
  IF current_ath IS NULL OR new_price_usd > current_ath THEN
    INSERT INTO public.ath (price_usd, ath_date, source, updated_at)
    VALUES (new_price_usd, new_ath_date, source_name, timezone('utc'::text, now()));
    
    -- Log the new ATH
    INSERT INTO public.price_update_logs (service, status, message)
    VALUES ('ath_update', 'success', 'New ATH recorded: ' || new_price_usd || ' USD on ' || new_ath_date);
  ELSE
    -- Log that no update was needed
    INSERT INTO public.price_update_logs (service, status, message)
    VALUES ('ath_update', 'info', 'No new ATH. Current ATH remains: ' || current_ath);
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_btc_monthly_close_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_btc_price()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    response http_response;
    price_data JSON;
    current_epoch BIGINT;
BEGIN
    -- Get current Unix timestamp
    current_epoch := extract(epoch from now())::BIGINT;
    
    -- Call the historical price API for the current time (USD)
    SELECT * INTO response FROM http_get(
        'https://mempool.space/api/v1/historical-price?currency=USD&timestamp=' || current_epoch::TEXT
    );
    
    -- Check response
    IF response.status = 200 AND response.content IS NOT NULL AND response.content != '' THEN
        -- Parse JSON response
        price_data := response.content::JSON;
        
        -- Insert the data into historical_prices
        INSERT INTO public.historical_prices (
            timestamp, 
            date, 
            price_usd
        ) VALUES (
            current_epoch, 
            now()::DATE, 
            (price_data->'USD'->>'value')::NUMERIC
        )
        ON CONFLICT (timestamp) DO NOTHING;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_fear_greed_index()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ DECLARE api_response JSONB; index_value INTEGER; index_classification VARCHAR(50); today_date DATE := CURRENT_DATE; BEGIN RAISE NOTICE 'Starting Fear & Greed Index update using Alternative.me API'; SELECT content::jsonb INTO api_response FROM http(('GET', 'https://api.alternative.me/fng/', NULL, NULL, NULL)::http_request); index_value := (api_response->'data'->0->>'value')::INTEGER; IF index_value IS NULL OR index_value < 0 OR index_value > 100 THEN RAISE EXCEPTION 'Invalid Fear & Greed index value received from Alternative.me API: %', index_value; END IF; IF index_value <= 25 THEN index_classification := 'Extreme Fear'; ELSIF index_value <= 45 THEN index_classification := 'Fear'; ELSIF index_value <= 55 THEN index_classification := 'Neutral'; ELSIF index_value <= 75 THEN index_classification := 'Greed'; ELSE index_classification := 'Extreme Greed'; END IF; RAISE NOTICE 'Fetched Fear & Greed Index: % (%) for date %', index_value, index_classification, today_date; IF EXISTS (SELECT 1 FROM public.fear_greed_index WHERE date = today_date) THEN UPDATE public.fear_greed_index SET value = index_value, classification = index_classification, last_updated = timezone('utc'::text, now()) WHERE date = today_date; RAISE NOTICE 'Updated existing Fear & Greed Index entry for date %', today_date; ELSE INSERT INTO public.fear_greed_index (value, classification, date, last_updated) VALUES (index_value, index_classification, today_date, timezone('utc'::text, now())); RAISE NOTICE 'Inserted new Fear & Greed Index entry for date %', today_date; END IF; EXCEPTION WHEN OTHERS THEN RAISE WARNING 'Error updating Fear & Greed Index: %', SQLERRM; RAISE; END; $function$
;

CREATE OR REPLACE FUNCTION public.update_spot_price(new_price_usd numeric, source_name character varying DEFAULT 'coinpaprika'::character varying)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.spot_price (price_usd, source, updated_at)
  VALUES (new_price_usd, source_name, timezone('utc'::text, now()));
  
  -- Keep only the most recent 100 records to prevent unbounded growth
  DELETE FROM public.spot_price
  WHERE id NOT IN (
    SELECT id FROM public.spot_price
    ORDER BY updated_at DESC
    LIMIT 100
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_monthly_close(month_date date, close_price numeric)
 RETURNS TABLE(id bigint, date date, close numeric, was_updated boolean)
 LANGUAGE plpgsql
AS $function$
DECLARE
  result_record RECORD;
  was_update BOOLEAN := FALSE;
BEGIN
  -- Ensure we're using the last day of the month
  month_date := public.get_last_day_of_month(month_date);
  
  -- Attempt to update existing record
  UPDATE public.btc_monthly_close 
  SET close = close_price, updated_at = NOW()
  WHERE btc_monthly_close.date = month_date
  RETURNING btc_monthly_close.id, btc_monthly_close.date, btc_monthly_close.close INTO result_record;
  
  IF FOUND THEN
    was_update := TRUE;
  ELSE
    -- Insert new record if not found
    INSERT INTO public.btc_monthly_close (date, close)
    VALUES (month_date, close_price)
    RETURNING btc_monthly_close.id, btc_monthly_close.date, btc_monthly_close.close INTO result_record;
  END IF;
  
  RETURN QUERY SELECT result_record.id, result_record.date, result_record.close, was_update;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_monthly_close_completeness(start_date date DEFAULT '2010-07-31'::date, end_date date DEFAULT NULL::date)
 RETURNS TABLE(missing_month date)
 LANGUAGE plpgsql
AS $function$
DECLARE
  check_end_date DATE;
BEGIN
  -- Default to last month if end_date not provided
  IF end_date IS NULL THEN
    check_end_date := public.get_last_day_of_month((CURRENT_DATE - INTERVAL '1 month')::DATE);
  ELSE
    check_end_date := end_date;
  END IF;
  
  RETURN QUERY
  WITH RECURSIVE month_series AS (
    SELECT start_date as month_end
    UNION ALL
    SELECT public.get_last_day_of_month((month_end + INTERVAL '1 month')::DATE)
    FROM month_series
    WHERE month_end < check_end_date
  )
  SELECT ms.month_end
  FROM month_series ms
  LEFT JOIN public.btc_monthly_close bmc ON ms.month_end = bmc.date
  WHERE bmc.date IS NULL
  ORDER BY ms.month_end;
END;
$function$
;

grant delete on table "public"."ath" to "anon";

grant insert on table "public"."ath" to "anon";

grant references on table "public"."ath" to "anon";

grant select on table "public"."ath" to "anon";

grant trigger on table "public"."ath" to "anon";

grant truncate on table "public"."ath" to "anon";

grant update on table "public"."ath" to "anon";

grant delete on table "public"."ath" to "authenticated";

grant insert on table "public"."ath" to "authenticated";

grant references on table "public"."ath" to "authenticated";

grant select on table "public"."ath" to "authenticated";

grant trigger on table "public"."ath" to "authenticated";

grant truncate on table "public"."ath" to "authenticated";

grant update on table "public"."ath" to "authenticated";

grant delete on table "public"."ath" to "service_role";

grant insert on table "public"."ath" to "service_role";

grant references on table "public"."ath" to "service_role";

grant select on table "public"."ath" to "service_role";

grant trigger on table "public"."ath" to "service_role";

grant truncate on table "public"."ath" to "service_role";

grant update on table "public"."ath" to "service_role";

grant delete on table "public"."btc_monthly_close" to "anon";

grant insert on table "public"."btc_monthly_close" to "anon";

grant references on table "public"."btc_monthly_close" to "anon";

grant select on table "public"."btc_monthly_close" to "anon";

grant trigger on table "public"."btc_monthly_close" to "anon";

grant truncate on table "public"."btc_monthly_close" to "anon";

grant update on table "public"."btc_monthly_close" to "anon";

grant delete on table "public"."btc_monthly_close" to "authenticated";

grant insert on table "public"."btc_monthly_close" to "authenticated";

grant references on table "public"."btc_monthly_close" to "authenticated";

grant select on table "public"."btc_monthly_close" to "authenticated";

grant trigger on table "public"."btc_monthly_close" to "authenticated";

grant truncate on table "public"."btc_monthly_close" to "authenticated";

grant update on table "public"."btc_monthly_close" to "authenticated";

grant delete on table "public"."btc_monthly_close" to "service_role";

grant insert on table "public"."btc_monthly_close" to "service_role";

grant references on table "public"."btc_monthly_close" to "service_role";

grant select on table "public"."btc_monthly_close" to "service_role";

grant trigger on table "public"."btc_monthly_close" to "service_role";

grant truncate on table "public"."btc_monthly_close" to "service_role";

grant update on table "public"."btc_monthly_close" to "service_role";

grant delete on table "public"."csv_uploads" to "anon";

grant insert on table "public"."csv_uploads" to "anon";

grant references on table "public"."csv_uploads" to "anon";

grant select on table "public"."csv_uploads" to "anon";

grant trigger on table "public"."csv_uploads" to "anon";

grant truncate on table "public"."csv_uploads" to "anon";

grant update on table "public"."csv_uploads" to "anon";

grant delete on table "public"."csv_uploads" to "authenticated";

grant insert on table "public"."csv_uploads" to "authenticated";

grant references on table "public"."csv_uploads" to "authenticated";

grant select on table "public"."csv_uploads" to "authenticated";

grant trigger on table "public"."csv_uploads" to "authenticated";

grant truncate on table "public"."csv_uploads" to "authenticated";

grant update on table "public"."csv_uploads" to "authenticated";

grant delete on table "public"."csv_uploads" to "service_role";

grant insert on table "public"."csv_uploads" to "service_role";

grant references on table "public"."csv_uploads" to "service_role";

grant select on table "public"."csv_uploads" to "service_role";

grant trigger on table "public"."csv_uploads" to "service_role";

grant truncate on table "public"."csv_uploads" to "service_role";

grant update on table "public"."csv_uploads" to "service_role";

grant delete on table "public"."customers" to "anon";

grant insert on table "public"."customers" to "anon";

grant references on table "public"."customers" to "anon";

grant select on table "public"."customers" to "anon";

grant trigger on table "public"."customers" to "anon";

grant truncate on table "public"."customers" to "anon";

grant update on table "public"."customers" to "anon";

grant delete on table "public"."customers" to "authenticated";

grant insert on table "public"."customers" to "authenticated";

grant references on table "public"."customers" to "authenticated";

grant select on table "public"."customers" to "authenticated";

grant trigger on table "public"."customers" to "authenticated";

grant truncate on table "public"."customers" to "authenticated";

grant update on table "public"."customers" to "authenticated";

grant delete on table "public"."customers" to "service_role";

grant insert on table "public"."customers" to "service_role";

grant references on table "public"."customers" to "service_role";

grant select on table "public"."customers" to "service_role";

grant trigger on table "public"."customers" to "service_role";

grant truncate on table "public"."customers" to "service_role";

grant update on table "public"."customers" to "service_role";

grant delete on table "public"."fear_greed_index" to "anon";

grant insert on table "public"."fear_greed_index" to "anon";

grant references on table "public"."fear_greed_index" to "anon";

grant select on table "public"."fear_greed_index" to "anon";

grant trigger on table "public"."fear_greed_index" to "anon";

grant truncate on table "public"."fear_greed_index" to "anon";

grant update on table "public"."fear_greed_index" to "anon";

grant delete on table "public"."fear_greed_index" to "authenticated";

grant insert on table "public"."fear_greed_index" to "authenticated";

grant references on table "public"."fear_greed_index" to "authenticated";

grant select on table "public"."fear_greed_index" to "authenticated";

grant trigger on table "public"."fear_greed_index" to "authenticated";

grant truncate on table "public"."fear_greed_index" to "authenticated";

grant update on table "public"."fear_greed_index" to "authenticated";

grant delete on table "public"."fear_greed_index" to "service_role";

grant insert on table "public"."fear_greed_index" to "service_role";

grant references on table "public"."fear_greed_index" to "service_role";

grant select on table "public"."fear_greed_index" to "service_role";

grant trigger on table "public"."fear_greed_index" to "service_role";

grant truncate on table "public"."fear_greed_index" to "service_role";

grant update on table "public"."fear_greed_index" to "service_role";

grant delete on table "public"."spot_price" to "anon";

grant insert on table "public"."spot_price" to "anon";

grant references on table "public"."spot_price" to "anon";

grant select on table "public"."spot_price" to "anon";

grant trigger on table "public"."spot_price" to "anon";

grant truncate on table "public"."spot_price" to "anon";

grant update on table "public"."spot_price" to "anon";

grant delete on table "public"."spot_price" to "authenticated";

grant insert on table "public"."spot_price" to "authenticated";

grant references on table "public"."spot_price" to "authenticated";

grant select on table "public"."spot_price" to "authenticated";

grant trigger on table "public"."spot_price" to "authenticated";

grant truncate on table "public"."spot_price" to "authenticated";

grant update on table "public"."spot_price" to "authenticated";

grant delete on table "public"."spot_price" to "service_role";

grant insert on table "public"."spot_price" to "service_role";

grant references on table "public"."spot_price" to "service_role";

grant select on table "public"."spot_price" to "service_role";

grant trigger on table "public"."spot_price" to "service_role";

grant truncate on table "public"."spot_price" to "service_role";

grant update on table "public"."spot_price" to "service_role";

grant delete on table "public"."subscriptions" to "anon";

grant insert on table "public"."subscriptions" to "anon";

grant references on table "public"."subscriptions" to "anon";

grant select on table "public"."subscriptions" to "anon";

grant trigger on table "public"."subscriptions" to "anon";

grant truncate on table "public"."subscriptions" to "anon";

grant update on table "public"."subscriptions" to "anon";

grant delete on table "public"."subscriptions" to "authenticated";

grant insert on table "public"."subscriptions" to "authenticated";

grant references on table "public"."subscriptions" to "authenticated";

grant select on table "public"."subscriptions" to "authenticated";

grant trigger on table "public"."subscriptions" to "authenticated";

grant truncate on table "public"."subscriptions" to "authenticated";

grant update on table "public"."subscriptions" to "authenticated";

grant delete on table "public"."subscriptions" to "service_role";

grant insert on table "public"."subscriptions" to "service_role";

grant references on table "public"."subscriptions" to "service_role";

grant select on table "public"."subscriptions" to "service_role";

grant trigger on table "public"."subscriptions" to "service_role";

grant truncate on table "public"."subscriptions" to "service_role";

grant update on table "public"."subscriptions" to "service_role";

grant delete on table "public"."terms_acceptance" to "anon";

grant insert on table "public"."terms_acceptance" to "anon";

grant references on table "public"."terms_acceptance" to "anon";

grant select on table "public"."terms_acceptance" to "anon";

grant trigger on table "public"."terms_acceptance" to "anon";

grant truncate on table "public"."terms_acceptance" to "anon";

grant update on table "public"."terms_acceptance" to "anon";

grant delete on table "public"."terms_acceptance" to "authenticated";

grant insert on table "public"."terms_acceptance" to "authenticated";

grant references on table "public"."terms_acceptance" to "authenticated";

grant select on table "public"."terms_acceptance" to "authenticated";

grant trigger on table "public"."terms_acceptance" to "authenticated";

grant truncate on table "public"."terms_acceptance" to "authenticated";

grant update on table "public"."terms_acceptance" to "authenticated";

grant delete on table "public"."terms_acceptance" to "service_role";

grant insert on table "public"."terms_acceptance" to "service_role";

grant references on table "public"."terms_acceptance" to "service_role";

grant select on table "public"."terms_acceptance" to "service_role";

grant trigger on table "public"."terms_acceptance" to "service_role";

grant truncate on table "public"."terms_acceptance" to "service_role";

grant update on table "public"."terms_acceptance" to "service_role";

grant delete on table "public"."transactions" to "anon";

grant insert on table "public"."transactions" to "anon";

grant references on table "public"."transactions" to "anon";

grant select on table "public"."transactions" to "anon";

grant trigger on table "public"."transactions" to "anon";

grant truncate on table "public"."transactions" to "anon";

grant update on table "public"."transactions" to "anon";

grant delete on table "public"."transactions" to "authenticated";

grant insert on table "public"."transactions" to "authenticated";

grant references on table "public"."transactions" to "authenticated";

grant select on table "public"."transactions" to "authenticated";

grant trigger on table "public"."transactions" to "authenticated";

grant truncate on table "public"."transactions" to "authenticated";

grant update on table "public"."transactions" to "authenticated";

grant delete on table "public"."transactions" to "service_role";

grant insert on table "public"."transactions" to "service_role";

grant references on table "public"."transactions" to "service_role";

grant select on table "public"."transactions" to "service_role";

grant trigger on table "public"."transactions" to "service_role";

grant truncate on table "public"."transactions" to "service_role";

grant update on table "public"."transactions" to "service_role";

create policy "Allow authenticated users to read ATH"
on "public"."ath"
as permissive
for select
to authenticated
using (true);


create policy "Only service role can modify ATH"
on "public"."ath"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "Allow read access to monthly close data"
on "public"."btc_monthly_close"
as permissive
for select
to authenticated
using (true);


create policy "Allow authenticated users to insert their own uploads"
on "public"."csv_uploads"
as permissive
for insert
to authenticated
with check ((auth.uid() = user_id));


create policy "Allow users to delete their own uploads"
on "public"."csv_uploads"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "Allow users to select their own uploads"
on "public"."csv_uploads"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Allow users to update their own uploads"
on "public"."csv_uploads"
as permissive
for update
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Users can only see own customer data"
on "public"."customers"
as permissive
for all
to public
using ((auth.uid() = id));


create policy "Allow all users to read fear_greed_index"
on "public"."fear_greed_index"
as permissive
for select
to public
using (true);


create policy "Allow authenticated users to insert/update fear_greed_index"
on "public"."fear_greed_index"
as permissive
for all
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Allow authenticated users to read fear_greed_index"
on "public"."fear_greed_index"
as permissive
for select
to authenticated
using (true);


create policy "Only service role can modify fear_greed_index"
on "public"."fear_greed_index"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "Allow authenticated users to read spot price"
on "public"."spot_price"
as permissive
for select
to authenticated
using (true);


create policy "Only service role can modify spot price"
on "public"."spot_price"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "Service role can manage subscriptions"
on "public"."subscriptions"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "Users can delete own subscriptions"
on "public"."subscriptions"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "Users can insert own subscriptions"
on "public"."subscriptions"
as permissive
for insert
to authenticated
with check ((auth.uid() = user_id));


create policy "Users can only see own subscriptions"
on "public"."subscriptions"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Users can update own subscriptions"
on "public"."subscriptions"
as permissive
for update
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Admins and server can insert terms acceptances"
on "public"."terms_acceptance"
as permissive
for insert
to authenticated
with check (((auth.uid() = user_id) OR true));


create policy "Admins can read all terms acceptances"
on "public"."terms_acceptance"
as permissive
for select
to authenticated
using (true);


create policy "Nobody can delete terms acceptances"
on "public"."terms_acceptance"
as permissive
for delete
to authenticated
using (false);


create policy "Nobody can update terms acceptances"
on "public"."terms_acceptance"
as permissive
for update
to authenticated
using (false);


create policy "Users can read their own terms acceptances"
on "public"."terms_acceptance"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Users can delete their own transactions"
on "public"."transactions"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "Users can insert their own transactions"
on "public"."transactions"
as permissive
for insert
to authenticated
with check ((auth.uid() = user_id));


create policy "Users can update their own transactions"
on "public"."transactions"
as permissive
for update
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Users can view their own transactions"
on "public"."transactions"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


CREATE TRIGGER update_btc_monthly_close_updated_at BEFORE UPDATE ON public.btc_monthly_close FOR EACH ROW EXECUTE FUNCTION update_btc_monthly_close_updated_at();

CREATE TRIGGER update_transactions_updated_at BEFORE UPDATE ON public.transactions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();



