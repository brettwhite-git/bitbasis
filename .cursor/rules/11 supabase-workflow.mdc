---
description: 
globs: 
alwaysApply: true
---
# Supabase Local & Remote Database Workflow

## Current Setup Overview

### Local Environment
- **Project ID:** npcvbxrshuflujcnikon
- **Environment:** Docker-based Supabase setup
- **Database Connection:** `postgresql://postgres:postgres@localhost:54322/postgres`
- **API Endpoint:** http://127.0.0.1:54321
- **Supabase Studio:** http://127.0.0.1:54323
- **Email Testing:** http://127.0.0.1:54324

### Remote Environment
- **Project ID:** npcvbxrshuflujcnikon
- **Project Reference:** npcvbxrshuflujcnikon
- **Database Connection:** Managed by Supabase
- **API Endpoint:** https://npcvbxrshuflujcnikon.supabase.co

## Identified Issues & Best Practices

### Issues We've Encountered

1. **Migration Naming Inconsistency**
   - Files not following timestamp convention (`<timestamp>_name.sql`)
   - Manual fixes needed for migration history

2. **Local-Remote Discrepancies**
   - Cron jobs and edge functions may exist in production but not locally
   - RLS policies may differ between environments
   - Database schemas get out of sync

3. **Direct Database Modifications**
   - Changes made directly in Supabase Studio or SQL Editor bypass migration tracking
   - Hard to replicate these changes in local environment

4. **Environment Variable Management**
   - Different values needed for local vs. remote development
   - Credentials and secrets management

### Best Practices Workflow

## 1. Development Workflow

### A. Starting a New Feature

1. **Always start with a fresh sync:**
   ```bash
   # Ensure local is up-to-date with remote
   supabase db pull
   
   # Verify migration state
   supabase migration list
   ```

2. **Create feature branch:**
   ```bash
   git checkout -b feature/your-feature-name
   ```

3. **Create new migrations for schema changes:**
   ```bash
   # Using the timestamp format YYYYMMDDHHMMSS
   touch supabase/migrations/$(date +%Y%m%d%H%M%S)_descriptive_name.sql
   ```

### B. Testing Locally

1. **Apply migrations to local DB:**
   ```bash
   # Either directly with psql
   PGPASSWORD=postgres psql -h localhost -p 54322 -U postgres -d postgres -f supabase/migrations/your_migration.sql
   
   # Or using Supabase CLI
   supabase migration up
   ```

2. **Create seed data for testing:**
   ```bash
   # Create a seed file if needed
   touch supabase/seed.sql
   
   # Apply seed data
   PGPASSWORD=postgres psql -h localhost -p 54322 -U postgres -d postgres -f supabase/seed.sql
   ```

3. **Test changes with Next.js:**
   ```bash
   npm run dev
   ```

### C. Committing Changes

1. **Always commit migration files with related code:**
   ```bash
   git add supabase/migrations/your_migration.sql
   git add related/code/files.ts
   git commit -m "feat: descriptive message about your changes"
   ```

## 2. Special Considerations

### A. Cron Jobs & Edge Functions

**Key Issue:** Cron jobs set up in production won't automatically sync to local.

**Solution:**
1. **Always include cron jobs in migration files:**
   ```sql
   -- Example migration including a cron job
   CREATE OR REPLACE FUNCTION public.my_scheduled_function() 
   RETURNS void AS $$
   BEGIN
     -- Function logic here
   END;
   $$ LANGUAGE plpgsql;
   
   -- Create the cron job
   SELECT cron.schedule(
     'job-name',
     '0 0 * * *', -- Schedule (daily at midnight)
     'SELECT public.my_scheduled_function()'
   );
   ```

2. **Document all cron jobs in a central place:**
   Create a `CRON-JOBS.md` file documenting all scheduled jobs.

### B. RLS Policies

**Key Issue:** RLS policies may differ between environments.

**Solution:**
1. **Always include complete RLS setup in migrations:**
   ```sql
   -- Drop existing policies first to avoid errors
   DROP POLICY IF EXISTS "policy_name" ON table_name;
   
   -- Create new policy
   CREATE POLICY "policy_name" 
   ON table_name
   FOR SELECT 
   TO authenticated
   USING (auth.uid() = user_id);
   ```

2. **Test RLS thoroughly in local environment:**
   ```bash
   # Using direct SQL to test policy with different users
   PGPASSWORD=postgres psql -h localhost -p 54322 -U postgres -d postgres -c "
   -- Set session to simulate authenticated user
   SET LOCAL role = 'authenticated';
   SET LOCAL request.jwt.claims = '{\"sub\": \"test-user-id\"}';
   
   -- Test query
   SELECT * FROM your_table;
   "
   ```

### C. Environment Management

**Key Issue:** Need different settings for local vs. remote.

**Solution:**
1. **Use .env.local for local development:**
   ```
   # Local settings
   NEXT_PUBLIC_SUPABASE_URL=http://127.0.0.1:54321
   NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

2. **Use .env.production for production:**
   ```
   # Production settings
   NEXT_PUBLIC_SUPABASE_URL=https://npcvbxrshuflujcnikon.supabase.co
   NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

3. **Never commit .env files:**
   Add to .gitignore and provide .env.example templates.

## 3. Deployment Process

### A. Testing Before Deployment

1. **Create a fresh local instance to verify migrations:**
   ```bash
   supabase stop
   supabase start
   ```

2. **Apply all migrations:**
   ```bash
   supabase migration up
   ```

3. **Verify application works with fresh DB instance.**

### B. Deploying to Remote

1. **Always review migration files before pushing:**
   ```bash
   # See what you're about to push
   supabase db diff --linked
   ```

2. **Push migrations to remote:**
   ```bash
   supabase db push
   ```

3. **Verify remote deployment:**
   Test the deployed application with production DB.

## 4. Troubleshooting Common Issues

### A. Migration History Issues

**Problem:** Migration history out of sync.
**Solution:**
```bash
# Check migration state
supabase migration list

# Repair specific migrations
supabase migration repair --status applied 20240430000001
```

### B. Local Database Reset

**Problem:** Local database in bad state.

**Solution:**
```bash
# Reset entirely
supabase db reset

# Pull fresh from remote
supabase db pull
```

### C. Database Connection Issues

**Problem:** Cannot connect to database.

**Solution:**
```bash
# Check if docker containers are running
docker ps | grep supabase

# Restart if needed
supabase stop
supabase start
```

## 5. Advanced Tips

### A. Database Snapshots

Create regular snapshots before major changes:
```bash
# Backup local database
PGPASSWORD=postgres pg_dump -h localhost -p 54322 -U postgres postgres > backup_$(date +%Y%m%d).sql
```

### B. Reverting Migrations

Always include a way to revert changes:
```sql
-- Migration to add a column
ALTER TABLE your_table ADD COLUMN new_column TEXT;

-- How to revert (in comments or separate file)
-- ALTER TABLE your_table DROP COLUMN new_column;
```

### C. Testing Production-Like Environment

Use Docker Compose to create a more production-like environment:
```bash
# Create a testing environment with supabase and your app
docker-compose -f docker-compose.test.yml up
```

## Remember

1. **Never make direct changes to the production database** without corresponding migrations
2. **Always test migrations locally** before applying to production
3. **Keep local and remote in sync** to avoid surprises during deployment
4. **Document all cron jobs and edge functions** for better maintenance
5. **Use version control for all database changes** through migration files 
